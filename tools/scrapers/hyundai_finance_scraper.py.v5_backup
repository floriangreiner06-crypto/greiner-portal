#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Hyundai Finance Scraper V5 - CSV Download mit Popup-Handling
=============================================================

√Ñnderungen V5:
- Popup-Dialog f√ºr CSV-Download erkennen
- "Download"-Button im Popup klicken
- Warten auf CSV-Datei mit Zeitstempel-Namen
- Robusteres Datei-Handling

Author: Auto Greiner GmbH
Date: 11.11.2025
"""

import os
import sys
import time
import json
import csv
import glob
from pathlib import Path
from datetime import datetime
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException
from selenium.webdriver.chrome.options import Options

# ============================================================================
# KONFIGURATION
# ============================================================================

# Credentials
PORTAL_URL = "https://fiona.hyundaifinance.eu/#/dealer-portal"
USERNAME = "Christian.aichinger@auto-greiner.de"
PASSWORD = "Hyundaikona2020!"
STANDORT_NAME = "Auto Greiner"

# Pfade
BASE_DIR = "/opt/greiner-portal"
SCREENSHOTS_DIR = "/tmp/hyundai_screenshots"
DB_PATH = f"{BASE_DIR}/data/greiner_controlling.db"

# Timeouts
WAIT_SHORT = 5
WAIT_MEDIUM = 10
WAIT_LONG = 30
WAIT_DOWNLOAD = 20

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

def setup_driver():
    """Chrome WebDriver mit Download-Konfiguration initialisieren"""
    print("üîß Initialisiere WebDriver...")
    
    chrome_options = Options()
    chrome_options.add_argument('--headless=new')
    chrome_options.add_argument('--no-sandbox')
    chrome_options.add_argument('--disable-dev-shm-usage')
    chrome_options.add_argument('--disable-gpu')
    chrome_options.add_argument('--window-size=1920,1080')
    chrome_options.add_argument('--lang=de-DE')
    
    # Download-Einstellungen
    prefs = {
        'download.default_directory': SCREENSHOTS_DIR,
        'download.prompt_for_download': False,
        'download.directory_upgrade': True,
        'safebrowsing.enabled': False
    }
    chrome_options.add_experimental_option('prefs', prefs)
    
    driver = webdriver.Chrome(options=chrome_options)
    driver.implicitly_wait(5)
    
    print("‚úÖ WebDriver bereit")
    return driver

def take_screenshot(driver, name):
    """Screenshot speichern"""
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    filename = f"{timestamp}_{name}.png"
    filepath = os.path.join(SCREENSHOTS_DIR, filename)
    driver.save_screenshot(filepath)
    print(f"   üì∏ {filename}")

def wait_for_csv_download(timeout=WAIT_DOWNLOAD):
    """Warte auf neue CSV-Datei im Download-Verzeichnis"""
    print(f"   ‚è≥ Warte auf CSV-Download (max {timeout}s)...")
    
    start_time = time.time()
    initial_files = set(glob.glob(os.path.join(SCREENSHOTS_DIR, "*.csv")))
    
    while time.time() - start_time < timeout:
        current_files = set(glob.glob(os.path.join(SCREENSHOTS_DIR, "*.csv")))
        new_files = current_files - initial_files
        
        if new_files:
            csv_file = list(new_files)[0]
            # Warte bis Datei vollst√§ndig geschrieben ist
            time.sleep(2)
            print(f"   ‚úÖ CSV heruntergeladen: {os.path.basename(csv_file)}")
            return csv_file
        
        time.sleep(1)
    
    return None

def parse_csv_file(csv_file):
    """Parse CSV-Datei und extrahiere Fahrzeugdaten"""
    print(f"\nüìä Parse CSV-Datei: {os.path.basename(csv_file)}")
    
    vehicles = []
    
    # Versuche verschiedene Encodings
    encodings = ['utf-8', 'latin-1', 'iso-8859-1', 'cp1252']
    
    for encoding in encodings:
        try:
            with open(csv_file, 'r', encoding=encoding) as f:
                # Erkenne Delimiter
                sample = f.read(1024)
                f.seek(0)
                
                delimiter = ';' if sample.count(';') > sample.count(',') else ','
                
                reader = csv.DictReader(f, delimiter=delimiter)
                
                for row in reader:
                    # VIN extrahieren (17 Zeichen)
                    vin = None
                    for key, value in row.items():
                        if value and len(str(value)) == 17 and str(value).isalnum():
                            vin = str(value).upper()
                            break
                    
                    if vin:
                        vehicle = {
                            'vin': vin,
                            'raw_data': dict(row)
                        }
                        vehicles.append(vehicle)
                
                print(f"   ‚úÖ {len(vehicles)} Fahrzeuge gefunden")
                print(f"   ‚ÑπÔ∏è  Encoding: {encoding}, Delimiter: '{delimiter}'")
                
                # Zeige erste 3 VINs
                if vehicles:
                    print(f"\n   üìã Erste VINs:")
                    for i, v in enumerate(vehicles[:3], 1):
                        print(f"      {i}. {v['vin']}")
                
                return vehicles
                
        except Exception as e:
            continue
    
    print(f"   ‚ö†Ô∏è  Fehler beim Parsen der CSV")
    return []

# ============================================================================
# MAIN SCRAPER
# ============================================================================

def scrape_hyundai_finance():
    """Hauptfunktion f√ºr Hyundai Finance Scraping"""
    
    print("\n" + "="*60)
    print("üöó HYUNDAI FINANCE SCRAPER V5")
    print("="*60)
    
    # Erstelle Screenshot-Verzeichnis
    os.makedirs(SCREENSHOTS_DIR, exist_ok=True)
    
    driver = None
    csv_file = None
    
    try:
        # ========================================
        # SCHRITT 1: LOGIN
        # ========================================
        driver = setup_driver()
        
        print("\nüîê Login...")
        driver.get(PORTAL_URL)
        time.sleep(WAIT_SHORT)
        
        # Email eingeben
        email_input = driver.find_element(By.CSS_SELECTOR, "input[type='email']")
        email_input.clear()
        email_input.send_keys(USERNAME)
        
        # Weiter-Button
        next_button = driver.find_element(By.CSS_SELECTOR, "button[type='submit']")
        next_button.click()
        time.sleep(WAIT_SHORT)
        
        # Passwort eingeben
        password_input = driver.find_element(By.CSS_SELECTOR, "input[type='password']")
        password_input.clear()
        password_input.send_keys(PASSWORD)
        
        # Login-Button
        login_button = driver.find_element(By.CSS_SELECTOR, "button[type='submit']")
        login_button.click()
        time.sleep(WAIT_MEDIUM)
        
        take_screenshot(driver, "01_nach_login")
        print("‚úÖ Login erfolgreich")
        
        # ========================================
        # SCHRITT 2: STANDORT W√ÑHLEN
        # ========================================
        print("\nüè¢ Standort ausw√§hlen...")
        
        wait = WebDriverWait(driver, WAIT_MEDIUM)
        standort_card = wait.until(
            EC.element_to_be_clickable((By.XPATH, f"//div[contains(text(), '{STANDORT_NAME}')]"))
        )
        standort_card.click()
        time.sleep(WAIT_SHORT)
        
        # "Standort ausw√§hlen" Button
        select_button = wait.until(
            EC.element_to_be_clickable((By.XPATH, "//button[contains(., 'Standort ausw√§hlen')]"))
        )
        select_button.click()
        time.sleep(WAIT_MEDIUM)
        
        take_screenshot(driver, "02_standort_gew√§hlt")
        print("‚úÖ Standort ausgew√§hlt")
        
        # ========================================
        # SCHRITT 3: EKF PORTAL (Tab-Wechsel)
        # ========================================
        print("\nüîÑ Wechsel zu EKF Portal...")
        
        # Warte auf "Einkaufsfinanzierung" Kachel
        ekf_tile = wait.until(
            EC.element_to_be_clickable((By.XPATH, "//div[contains(., 'Einkaufsfinanzierung')]"))
        )
        ekf_tile.click()
        time.sleep(WAIT_MEDIUM)
        
        # Wechsel zu neuem Tab
        if len(driver.window_handles) > 1:
            driver.switch_to.window(driver.window_handles[-1])
            time.sleep(WAIT_SHORT)
        
        take_screenshot(driver, "03_ekf_portal")
        print("‚úÖ EKF Portal ge√∂ffnet")
        
        # ========================================
        # SCHRITT 4: BESTANDSLISTE
        # ========================================
        print("\nüìã Navigation zur BESTANDSLISTE...")
        
        # URL direkt √∂ffnen ist am sichersten
        driver.get("https://ekf.hyundaifinance.eu/account/stocklist/search")
        time.sleep(WAIT_MEDIUM)
        
        take_screenshot(driver, "04_bestandsliste")
        print("‚úÖ Bestandsliste geladen")
        
        # ========================================
        # SCHRITT 5: CSV DOWNLOAD
        # ========================================
        print("\nüì• Download Bestandsliste CSV...")
        
        # Finde Download-Button (Icon mit download_file)
        print("   ‚Üí Suche Download-Button...")
        
        # Mehrere Strategien f√ºr Download-Button
        download_clicked = False
        
        # Strategie 1: mat-icon mit "download_file"
        try:
            download_icons = driver.find_elements(By.XPATH, "//mat-icon[contains(text(), 'download_file')]")
            if download_icons:
                download_icons[0].click()
                download_clicked = True
                print("   ‚úì Download-Icon geklickt (Strategie 1)")
        except:
            pass
        
        # Strategie 2: Button mit Download-Icon
        if not download_clicked:
            try:
                download_button = driver.find_element(By.XPATH, "//button[.//mat-icon[contains(text(), 'download_file')]]")
                download_button.click()
                download_clicked = True
                print("   ‚úì Download-Button geklickt (Strategie 2)")
            except:
                pass
        
        # Strategie 3: Beliebiges klickbares Element mit Download-Icon
        if not download_clicked:
            try:
                download_element = driver.find_element(By.XPATH, "//*[contains(@class, 'download') or contains(@aria-label, 'Download')]")
                download_element.click()
                download_clicked = True
                print("   ‚úì Download-Element geklickt (Strategie 3)")
            except:
                pass
        
        if not download_clicked:
            raise Exception("Download-Button nicht gefunden!")
        
        time.sleep(WAIT_SHORT)
        take_screenshot(driver, "05_download_geklickt")
        
        # ========================================
        # SCHRITT 6: POPUP-HANDLING
        # ========================================
        print("\nüí¨ Popup-Dialog f√ºr Download...")
        
        # Warte auf Popup mit "CSV-Datei" Text
        try:
            popup = wait.until(
                EC.presence_of_element_located((By.XPATH, "//*[contains(text(), 'CSV-Datei')]"))
            )
            print("   ‚úì Popup erschienen")
            time.sleep(2)
            
            take_screenshot(driver, "06_popup_erschienen")
            
            # Suche "Download"-Button im Popup
            popup_download_button = wait.until(
                EC.element_to_be_clickable((By.XPATH, "//button[contains(., 'Download')]"))
            )
            popup_download_button.click()
            print("   ‚úì Download-Button im Popup geklickt")
            
            time.sleep(2)
            take_screenshot(driver, "07_popup_download_geklickt")
            
        except TimeoutException:
            print("   ‚ö†Ô∏è  Kein Popup gefunden - direkter Download?")
        
        # ========================================
        # SCHRITT 7: WARTE AUF CSV-DATEI
        # ========================================
        csv_file = wait_for_csv_download(timeout=WAIT_DOWNLOAD)
        
        if not csv_file:
            print("\n‚ö†Ô∏è  WARNUNG: Keine CSV-Datei heruntergeladen!")
            print("   ‚Üí Pr√ºfe Downloads manuell:")
            print(f"   ‚Üí ls -lh {SCREENSHOTS_DIR}/*.csv")
            
            # Liste vorhandene CSVs
            existing_csvs = glob.glob(os.path.join(SCREENSHOTS_DIR, "*.csv"))
            if existing_csvs:
                print(f"\n   ‚ÑπÔ∏è  Vorhandene CSV-Dateien:")
                for csv in existing_csvs:
                    print(f"      - {os.path.basename(csv)}")
                
                # Nimm die neueste
                csv_file = max(existing_csvs, key=os.path.getctime)
                print(f"\n   ‚Üí Verwende neueste CSV: {os.path.basename(csv_file)}")
        
        # ========================================
        # SCHRITT 8: CSV PARSEN
        # ========================================
        if csv_file and os.path.exists(csv_file):
            vehicles = parse_csv_file(csv_file)
            
            if vehicles:
                print(f"\n‚úÖ CSV ERFOLGREICH GEPARST!")
                print(f"   üìä {len(vehicles)} Fahrzeuge gefunden")
                
                # Speichere JSON f√ºr weitere Verarbeitung
                json_file = csv_file.replace('.csv', '_parsed.json')
                with open(json_file, 'w', encoding='utf-8') as f:
                    json.dump(vehicles, f, indent=2, ensure_ascii=False)
                print(f"   üíæ JSON gespeichert: {os.path.basename(json_file)}")
                
                return vehicles
            else:
                print("\n‚ö†Ô∏è  Keine Fahrzeuge in CSV gefunden")
                return []
        else:
            print("\n‚ùå CSV-Datei nicht gefunden!")
            return []
        
    except Exception as e:
        print(f"\n‚ùå FEHLER: {str(e)}")
        if driver:
            take_screenshot(driver, "99_error")
        import traceback
        traceback.print_exc()
        return []
        
    finally:
        if driver:
            driver.quit()
            print("\nüîö Browser geschlossen")

# ============================================================================
# MAIN
# ============================================================================

if __name__ == "__main__":
    print("\n" + "="*60)
    print("üöÄ HYUNDAI FINANCE SCRAPER V5 - START")
    print("="*60)
    print(f"‚è∞ Zeit: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"üìÇ Screenshots: {SCREENSHOTS_DIR}")
    print("="*60)
    
    vehicles = scrape_hyundai_finance()
    
    print("\n" + "="*60)
    if vehicles:
        print(f"‚úÖ SCRAPING ERFOLGREICH!")
        print(f"üìä {len(vehicles)} Fahrzeuge gefunden")
        print("\nüéØ N√ÑCHSTE SCHRITTE:")
        print("   1. CSV pr√ºfen")
        print("   2. Spalten-Mapping anpassen")
        print("   3. DB-Import durchf√ºhren")
    else:
        print("‚ö†Ô∏è  KEINE FAHRZEUGE GEFUNDEN")
        print("   ‚Üí Pr√ºfe Screenshots in:")
        print(f"   ‚Üí {SCREENSHOTS_DIR}")
    print("="*60)
    
    sys.exit(0 if vehicles else 1)
